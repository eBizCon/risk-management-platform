{
  "source_skill": "plan-user-story-implementation-blueprint",
  "user_story": {
    "title": "Paginierung Übersicht eingereichter Kreditanträge",
    "as_a": "Kreditsachbearbeiter",
    "i_want": "die Übersicht aller eingereichten Kreditanträge seitenweise mit einer klaren Navigation nutzen können",
    "so_that": "ich auch bei vielen Anträgen effizient navigieren, einzelne Seiten gezielt ansteuern und meinen Arbeitskontext behalten kann"
  },
  "global_constraints": [
    "Backend Architecture Rule einhalten: Transport-Layer (SvelteKit-Routes) getrennt von Services/Repositories, DB-Zugriffe nur in Repositories, Zod-Validation in API-Routes/Form-Actions.",
    "E2E-Test-Regel einhalten: stabile data-testid-Attribute in kebab-case für relevante UI-Elemente der Pagination verwenden.",
    "Keine Änderungen am DB-Schema vornehmen.",
    "Implementierung auf die Processor-Übersicht (/processor) begrenzen; Applicant-Ansicht (/applications) bleibt außerhalb des Scopes dieser Story.",
    "Sortierung der Anträge standardmäßig nach createdAt absteigend (neueste zuerst) beibehalten."
  ],
  "tasks": [
    {
      "id": "T-001",
      "title": "Repository-Funktionen für paginierte Processor-Anträge und Statistiken hinzufügen",
      "user_story": {
        "title": "Paginierung Übersicht eingereichter Kreditanträge",
        "as_a": "Kreditsachbearbeiter",
        "i_want": "die Übersicht aller eingereichten Kreditanträge seitenweise mit einer klaren Navigation nutzen können",
        "so_that": "ich auch bei vielen Anträgen effizient navigieren, einzelne Seiten gezielt ansteuern und meinen Arbeitskontext behalten kann"
      },
      "constraints": [
        "Backend Architecture Rule einhalten: DB-Zugriffe nur in application.repository.ts.",
        "Keine Änderungen am DB-Schema.",
        "Pagination soll auf Basis von limit/offset mit fester Page Size von 20 umgesetzt werden."
      ],
      "goal": "Repository liefert für Processor-Anträge paginierte Ergebnisse und konsistente Statistiken für alle Status.",
      "blueprint_references": [
        "Abschnitt 3: Impact Map – Backend application.repository.ts",
        "Abschnitt 4.1: Repository: application.repository.ts",
        "Abschnitt 5: Daten- & Contract-Änderungen"
      ],
      "implementation_details": [
        "In src/lib/server/services/repositories/application.repository.ts eine Konstante PAGE_SIZE = 20 definieren (ggf. exportieren).",
        "Funktion getProcessorApplicationsPaginated(params: { status?: ApplicationStatus; page: number; pageSize: number }): Promise<{ items: Application[]; totalCount: number }> hinzufügen.",
        "In getProcessorApplicationsPaginated whereClause aus optionalem Status-Filter ableiten und totalCount via count(*)-Query ermitteln.",
        "Items-Query mit orderBy(desc(applications.createdAt)), limit(pageSize) und offset((page - 1) * pageSize) implementieren.",
        "Funktion getProcessorApplicationStats(): Promise<{ total: number; submitted: number; approved: number; rejected: number }> hinzufügen, die die Gesamtsummen pro Status liefert (z. B. via Aggregation oder mehrere count-Queries)."
      ],
      "scope": [
        "Nur Repositories in application.repository.ts anpassen.",
        "Keine Aufrufe in +page.server.ts oder UI in diesem Task ändern.",
        "Nur notwendige Importe für Drizzle/SQL-Funktionen ergänzen.",
        "Page Size fest auf 20 setzen und als Konstante vorhalten."
      ],
      "out_of_scope": [
        "Kein Refactoring bestehender Repository-Funktionen über das Notwendige hinaus.",
        "Keine Änderungen an anderen Entities oder Tabellen.",
        "Kein Einbau von Caching oder Performance-Tuning über einfache Queries hinaus."
      ],
      "artifacts": [
        "src/lib/server/services/repositories/application.repository.ts"
      ],
      "acceptance_criteria": [
        "getProcessorApplicationsPaginated liefert für eine gegebene page und pageSize die erwartete Anzahl von Application-Records und einen korrekten totalCount.",
        "Die Items sind nach createdAt absteigend sortiert.",
        "getProcessorApplicationStats liefert konsistente Werte für total, submitted, approved und rejected (Summe passt zur Gesamtzahl)."
      ],
      "checks": [
        "npm run test",
        "npm run check"
      ],
      "notes": [
        "Bei sehr großen Datenmengen können count(*)-Queries Performance-Thema werden; zunächst einfache Umsetzung, Optimierung bei Bedarf.",
        "Status-Filter ist optional; bei fehlendem Status werden alle relevanten Anträge berücksichtigt (fachlich: alle eingereichten Kreditanträge für Processor)."
      ]
    },
    {
      "id": "T-002",
      "title": "Server-Load der Processor-Seite auf Pagination umstellen",
      "user_story": {
        "title": "Paginierung Übersicht eingereichter Kreditanträge",
        "as_a": "Kreditsachbearbeiter",
        "i_want": "die Übersicht aller eingereichten Kreditanträge seitenweise mit einer klaren Navigation nutzen können",
        "so_that": "ich auch bei vielen Anträgen effizient navigieren, einzelne Seiten gezielt ansteuern und meinen Arbeitskontext behalten kann"
      },
      "constraints": [
        "Backend Architecture Rule einhalten: +page.server.ts darf nur Repository-Funktionen verwenden, keine direkten DB-Zugriffe.",
        "Query-Parameter page muss robust gegen ungültige Werte sein und auf einen sinnvollen Bereich (>=1, <=totalPages) gecappt werden.",
        "Status-Filter (status) muss beim Laden berücksichtigt und an die Repository-Funktion weitergegeben werden."
      ],
      "goal": "Der Load-Handler der Processor-Seite liefert paginierte Application-Daten inklusive Pagination-Metadaten an das Frontend.",
      "blueprint_references": [
        "Abschnitt 3: Impact Map – +page.server.ts",
        "Abschnitt 4.2: Server Load: src/routes/processor/+page.server.ts",
        "Abschnitt 5: Daten- & Contract-Änderungen – page Query-Parameter"
      ],
      "implementation_details": [
        "In src/routes/processor/+page.server.ts Query-Parameter page aus url.searchParams lesen und per parseInt auf eine Zahl mappen.",
        "Ungültige oder fehlende page-Werte auf 1 setzen (safePage).",
        "statusFilter wie bisher aus url.searchParams.get('status') lesen und als optionalen Parameter an getProcessorApplicationsPaginated übergeben.",
        "Rückgabewerte der Repository-Funktion ({ items, totalCount }) auswerten und totalPages = ceil(totalCount / PAGE_SIZE) berechnen.",
        "currentPage bestimmen, indem safePage auf den Bereich [1, totalPages] gecappt wird.",
        "Ein Objekt pagination mit page, pageSize, totalItems, totalPages an das Frontend zurückgeben.",
        "Stats via getProcessorApplicationStats laden und wie bisher an das Frontend weiterreichen."
      ],
      "scope": [
        "Nur src/routes/processor/+page.server.ts ändern.",
        "Abhängigkeit auf neue Repository-Funktionen herstellen.",
        "Fehlerverhalten bei fehlendem User oder falscher Rolle unverändert lassen.",
        "Keine Änderungen an anderen Routen."
      ],
      "out_of_scope": [
        "Kein Refactoring der Authentifizierungs-/Autorisierungslogik.",
        "Keine Änderung der Fehlermeldungen oder Statuscodes.",
        "Keine Anpassung anderer Load-Handler (z. B. /applications)."
      ],
      "artifacts": [
        "src/routes/processor/+page.server.ts"
      ],
      "acceptance_criteria": [
        "Der Load-Handler akzeptiert einen optionalen page-Query-Parameter und liefert Pagination-Metadaten im data-Objekt.",
        "Bei fehlender oder ungültiger page wird Seite 1 verwendet.",
        "Bei page-Werten größer als totalPages wird auf totalPages gecappt.",
        "Status-Filter bleibt funktional und kombiniert sich korrekt mit Pagination."
      ],
      "checks": [
        "npm run test",
        "npm run check"
      ],
      "notes": [
        "Bei totalCount = 0 sollte totalPages auf 1 gesetzt werden, damit das Frontend eine stabile Pagination anzeigen kann (leere Tabelle, aber definierte Seite 1)."
      ]
    },
    {
      "id": "T-003",
      "title": "Pagination-Komponente implementieren und in Processor-UI integrieren",
      "user_story": {
        "title": "Paginierung Übersicht eingereichter Kreditanträge",
        "as_a": "Kreditsachbearbeiter",
        "i_want": "die Übersicht aller eingereichten Kreditanträge seitenweise mit einer klaren Navigation nutzen können",
        "so_that": "ich auch bei vielen Anträgen effizient navigieren, einzelne Seiten gezielt ansteuern und meinen Arbeitskontext behalten kann"
      },
      "constraints": [
        "E2E-Test-Regel einhalten: data-testid-Attribute für alle wesentlichen Pagination-Elemente vergeben (first, prev, page-n, next, last).",
        "Maximal 5 aufeinanderfolgende Seiten im laufenden Block darstellen sowie erste/letzte Seite mit Ellipsen bei Bedarf (z. B. 1 2 3 4 5 … 10 20 >).",
        "Filter-Parameter (status) müssen beim Seitenwechsel im URL erhalten bleiben.",
        "UI-Styling soll sich konsistent in das bestehende Design (Buttons, Abstände, Farben) einfügen."
      ],
      "goal": "Die Processor-Übersicht zeigt eine funktionale und testbare Pagination-Leiste, mit der Seiten, erste/letzte und vor/zurück navigiert werden können.",
      "blueprint_references": [
        "Abschnitt 3: Impact Map – Frontend: +page.svelte und Pagination.svelte",
        "Abschnitt 4.3: Pagination-Komponente: src/lib/components/Pagination.svelte",
        "Abschnitt 4.4: Processor-Page UI: src/routes/processor/+page.svelte",
        "Abschnitt 6: Testplan – E2E-Tests für Pagination"
      ],
      "implementation_details": [
        "Neue Komponente src/lib/components/Pagination.svelte anlegen mit Props page, totalPages und onPageChange (Callback).",
        "Hilfsfunktion getVisiblePages(page, totalPages) in der Komponente implementieren, die maximal 5 aufeinanderfolgende Seiten zurückgibt (Startbereich, Mittelbereich, Endbereich gemäß Blueprint).",
        "Buttons/Links für erste Seite («), vorherige Seite (<), laufende Seiten, nächste Seite (>) und letzte Seite (») rendern.",
        "Ellipsen (…) anzeigen, wenn zwischen erster Seite und dem laufenden Block bzw. zwischen laufendem Block und letzter Seite Lücken bestehen.",
        "data-testid-Attribute gemäß E2E-Regel vergeben, z. B. processor-pagination, processor-pagination-first, processor-pagination-prev, processor-pagination-page-<n>, processor-pagination-next, processor-pagination-last.",
        "In src/routes/processor/+page.svelte die Komponente unterhalb der ApplicationTable einbinden und handlePageChange implementieren, der page im URL-Query anpasst und goto() aufruft.",
        "handleFilterChange so anpassen, dass bei Statuswechsel page auf 1 zurückgesetzt wird (page-Query-Parameter entfernen oder auf 1 setzen)."
      ],
      "scope": [
        "Nur UI-Änderungen in Pagination.svelte und +page.svelte (Processor).",
        "Keine Änderungen an ApplicationTable-Layout außer ggf. Abstände zur Pagination.",
        "Fokus auf Funktionalität und Testbarkeit der Pagination, nicht auf komplexe Responsive-Breakpoints."
      ],
      "out_of_scope": [
        "Keine Einführung einer generischen globalen Pagination-Library außerhalb dieses Projektes.",
        "Keine Änderungen an anderen Seiten, die Tabellen verwenden (z. B. Applicant-Ansicht).",
        "Keine Implementierung von Tastaturnavigation oder ARIA-Optimierungen über Standard-Attribute hinaus (kann separate Story sein)."
      ],
      "artifacts": [
        "src/lib/components/Pagination.svelte",
        "src/routes/processor/+page.svelte"
      ],
      "acceptance_criteria": [
        "Die Processor-Übersicht zeigt eine Pagination-Leiste mit Buttons für erste, vorherige, spezifische Seiten, nächste und letzte Seite.",
        "Bei vielen Seiten werden maximal 5 aufeinanderfolgende Seiten als laufender Block angezeigt, ergänzt um erste/letzte Seite und Ellipsen, vergleichbar mit dem Beispiel 1 2 3 4 5 … 10 20 >.",
        "Klicks auf die Seitenelemente führen zu einem Reload der Seite mit aktualisiertem page-Parameter und den korrekten Anträgen.",
        "Bei Statuswechsel wird automatisch auf Seite 1 zurückgesprungen und die Pagination aktualisiert sich entsprechend."
      ],
      "checks": [
        "npm run test",
        "npm run check",
        "npm run test:e2e"
      ],
      "notes": [
        "Aktive Seite sollte visuell hervorgehoben werden (z. B. farblicher Button).",
        "ARIA-Attribute wie aria-current=\"page\" für die aktive Seite können E2E- und Accessibility unterstützen."
      ]
    }
  ]
}
